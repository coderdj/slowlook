)]}'
{"version":3,"sources":["http/httpcall_common.js","http/httpcall_client.js","http/deprecated.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,mD;AACA,+E;;AAEA,wC;AACA,oE;AACA,I;;AAEA,8C;AACA,c;AACA,uE;;AAEA,4B;AACA,E;;;AAGA,uD;AACA,mC;AACA,2D;AACA,gE;AACA,gC;AACA,4E;;AAEA,wE;AACA,wE;AACA,S;AACA,mD;AACA,mB;AACA,2B;AACA,K;AACA,U;AACA,yB;AACA,G;AACA,E;;AAEA,U;;AAEA,G;AACA,yH;AACA,mE;AACA,gF;AACA,mH;AACA,kB;AACA,G;AACA,qC;AACA,qE;AACA,E;;AAEA,G;AACA,2H;AACA,mE;AACA,gF;AACA,mH;AACA,kB;AACA,G;AACA,sC;AACA,sE;AACA,E;;AAEA,G;AACA,yH;AACA,mE;AACA,gF;AACA,mH;AACA,kB;AACA,G;AACA,qC;AACA,qE;AACA,E;;AAEA,G;AACA,mM;AACA,mE;AACA,gF;AACA,mH;AACA,kB;AACA,G;AACA,qC;AACA,wE;AACA,E;;;;;;;;;;;;;;;;;;;AC9EA,G;AACA,6C;AACA,kB;AACA,qI;AACA,2C;AACA,4B;AACA,0E;AACA,qH;AACA,qG;AACA,+N;AACA,kG;AACA,6F;AACA,wI;AACA,mJ;AACA,kP;AACA,iM;AACA,G;AACA,sD;;AAEA,yC;;AAEA,oD;AACA,oD;AACA,uB;AACA,mB;AACA,G;;AAEA,0B;;AAEA,qC;AACA,oB;AACA,6E;;AAEA,wC;;AAEA,mB;;AAEA,gC;AACA,qB;AACA,2C;AACA,iD;AACA,G;;AAEA,sC;AACA,uD;AACA,oC;AACA,M;AACA,qC;;AAEA,8D;;AAEA,wC;AACA,6E;;AAEA,4C;AACA,yE;AACA,G;;AAEA,yB;AACA,qB;AACA,6C;AACA,qB;AACA,+E;AACA,mD;AACA,kD;AACA,G;;AAEA,wB;AACA,iD;AACA,G;;AAEA,2C;;AAEA,yC;;AAEA,oE;AACA,oE;AACA,kC;AACA,sC;AACA,4B;AACA,kC;AACA,gC;AACA,M;AACA,e;;AAEA,8C;AACA,8B;;;AAGA,gC;;AAEA,oE;AACA,qE;AACA,a;AACA,O;AACA,uB;AACA,Y;AACA,8C;AACA,iC;AACA,kD;AACA,0D;AACA,Q;AACA,4D;;AAEA,oD;;AAEA,0B;AACA,0C;;;AAGA,oB;AACA,0B;AACA,c;AACA,0B;AACA,4C;AACA,yB;AACA,oB;AACA,0B;AACA,M;;AAEA,2B;AACA,4C;AACA,6C;AACA,kB;AACA,qC;;AAEA,wB;AACA,yC;AACA,kC;AACA,6B;AACA,yC;AACA,gB;;AAEA,4B;AACA,2C;AACA,8C;;AAEA,gC;AACA,uD;;AAEA,wD;AACA,Y;AACA,yD;AACA,gE;AACA,qE;AACA,mB;AACA,gE;AACA,Y;AACA,qE;AACA,mE;AACA,sE;AACA,sE;AACA,wC;AACA,yE;AACA,wB;AACA,qE;;AAEA,sD;AACA,4C;AACA,kD;AACA,oC;AACA,0D;AACA,a;;AAEA,iC;;AAEA,2B;AACA,yC;AACA,6E;;AAEA,oC;AACA,S;AACA,O;AACA,M;;AAEA,yB;AACA,sB;;AAEA,iB;AACA,kB;AACA,G;;AAEA,E;;;;;;;;;;;;;;;;;;;ACtLA,iD;AACA,wB;AACA,mB","file":"/packages/http.js","sourcesContent":["makeErrorByStatus = function(statusCode, content) {\n  var MAX_LENGTH = 500; // if you change this, also change the appropriate test\n\n  var truncate = function(str, length) {\n    return str.length > length ? str.slice(0, length) + '...' : str;\n  };\n\n  var message = \"failed [\" + statusCode + \"]\";\n  if (content)\n    message += \" \" + truncate(content.replace(/\\n/g, \" \"), MAX_LENGTH);\n\n  return new Error(message);\n};\n\n\n// Fill in `response.data` if the content-type is JSON.\npopulateData = function(response) {\n  // Read Content-Type header, up to a ';' if there is one.\n  // A typical header might be \"application/json; charset=utf-8\"\n  // or just \"application/json\".\n  var contentType = (response.headers['content-type'] || ';').split(';')[0];\n\n  // Only try to parse data as JSON if server sets correct content type.\n  if (_.include(['application/json', 'text/javascript'], contentType)) {\n    try {\n      response.data = JSON.parse(response.content);\n    } catch (err) {\n      response.data = null;\n    }\n  } else {\n    response.data = null;\n  }\n};\n\nHTTP = {};\n\n/**\n * @summary Send an HTTP `GET` request. Equivalent to calling [`HTTP.call`](#http_call) with \"GET\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.get = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"GET\"].concat(_.toArray(arguments)));\n};\n\n/**\n * @summary Send an HTTP `POST` request. Equivalent to calling [`HTTP.call`](#http_call) with \"POST\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.post = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"POST\"].concat(_.toArray(arguments)));\n};\n\n/**\n * @summary Send an HTTP `PUT` request. Equivalent to calling [`HTTP.call`](#http_call) with \"PUT\" as the first argument.\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.put = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"PUT\"].concat(_.toArray(arguments)));\n};\n\n/**\n * @summary Send an HTTP `DELETE` request. Equivalent to calling [`HTTP.call`](#http_call) with \"DELETE\" as the first argument. (Named `del` to avoid conflic with the Javascript keyword `delete`)\n * @param {String} url The URL to which the request should be sent.\n * @param {Object} [callOptions] Options passed on to [`HTTP.call`](#http_call).\n * @param {Function} [asyncCallback] Callback that is called when the request is completed. Required on the client.\n * @locus Anywhere\n */\nHTTP.del = function (/* varargs */) {\n  return HTTP.call.apply(this, [\"DELETE\"].concat(_.toArray(arguments)));\n};\n","/**\n * @summary Perform an outbound HTTP request.\n * @locus Anywhere\n * @param {String} method The [HTTP method](http://en.wikipedia.org/wiki/HTTP_method) to use, such as \"`GET`\", \"`POST`\", or \"`HEAD`\".\n * @param {String} url The URL to retrieve.\n * @param {Object} [options]\n * @param {String} options.content String to use as the HTTP request body.\n * @param {Object} options.data JSON-able object to stringify and use as the HTTP request body. Overwrites `content`.\n * @param {String} options.query Query string to go in the URL. Overwrites any query string in `url`.\n * @param {Object} options.params Dictionary of request parameters to be encoded and placed in the URL (for GETs) or request body (for POSTs).  If `content` or `data` is specified, `params` will always be placed in the URL.\n * @param {String} options.auth HTTP basic authentication string of the form `\"username:password\"`\n * @param {Object} options.headers Dictionary of strings, headers to add to the HTTP request.\n * @param {Number} options.timeout Maximum time in milliseconds to wait for the request before failing.  There is no timeout by default.\n * @param {Boolean} options.followRedirects If `true`, transparently follow HTTP redirects. Cannot be set to `false` on the client. Default `true`.\n * @param {Object} options.npmRequestOptions On the server, `HTTP.call` is implemented by using the [npm `request` module](https://www.npmjs.com/package/request). Any options in this object will be passed directly to the `request` invocation.\n * @param {Function} [asyncCallback] Optional callback.  If passed, the method runs asynchronously, instead of synchronously, and calls asyncCallback.  On the client, this callback is required.\n */\nHTTP.call = function(method, url, options, callback) {\n\n  ////////// Process arguments //////////\n\n  if (! callback && typeof options === \"function\") {\n    // support (method, url, callback) argument list\n    callback = options;\n    options = null;\n  }\n\n  options = options || {};\n\n  if (typeof callback !== \"function\")\n    throw new Error(\n      \"Can't make a blocking HTTP call from the client; callback required.\");\n\n  method = (method || \"\").toUpperCase();\n\n  var headers = {};\n\n  var content = options.content;\n  if (options.data) {\n    content = JSON.stringify(options.data);\n    headers['Content-Type'] = 'application/json';\n  }\n\n  var params_for_url, params_for_body;\n  if (content || method === \"GET\" || method === \"HEAD\")\n    params_for_url = options.params;\n  else\n    params_for_body = options.params;\n\n  url = URL._constructUrl(url, options.query, params_for_url);\n\n  if (options.followRedirects === false)\n    throw new Error(\"Option followRedirects:false not supported on client.\");\n\n  if (_.has(options, 'npmRequestOptions')) {\n    throw new Error(\"Option npmRequestOptions not supported on client.\");\n  }\n\n  var username, password;\n  if (options.auth) {\n    var colonLoc = options.auth.indexOf(':');\n    if (colonLoc < 0)\n      throw new Error('auth option should be of the form \"username:password\"');\n    username = options.auth.substring(0, colonLoc);\n    password = options.auth.substring(colonLoc+1);\n  }\n\n  if (params_for_body) {\n    content = URL._encodeParams(params_for_body);\n  }\n\n  _.extend(headers, options.headers || {});\n\n  ////////// Callback wrapping //////////\n\n  // wrap callback to add a 'response' property on an error, in case\n  // we have both (http 4xx/5xx error, which has a response payload)\n  callback = (function(callback) {\n    return function(error, response) {\n      if (error && response)\n        error.response = response;\n      callback(error, response);\n    };\n  })(callback);\n\n  // safety belt: only call the callback once.\n  callback = _.once(callback);\n\n\n  ////////// Kickoff! //////////\n\n  // from this point on, errors are because of something remote, not\n  // something we should check in advance. Turn exceptions into error\n  // results.\n  try {\n    // setup XHR object\n    var xhr;\n    if (typeof XMLHttpRequest !== \"undefined\")\n      xhr = new XMLHttpRequest();\n    else if (typeof ActiveXObject !== \"undefined\")\n      xhr = new ActiveXObject(\"Microsoft.XMLHttp\"); // IE6\n    else\n      throw new Error(\"Can't create XMLHttpRequest\"); // ???\n\n    xhr.open(method, url, true, username, password);\n\n    for (var k in headers)\n      xhr.setRequestHeader(k, headers[k]);\n\n\n    // setup timeout\n    var timed_out = false;\n    var timer;\n    if (options.timeout) {\n      timer = Meteor.setTimeout(function() {\n        timed_out = true;\n        xhr.abort();\n      }, options.timeout);\n    };\n\n    // callback on complete\n    xhr.onreadystatechange = function(evt) {\n      if (xhr.readyState === 4) { // COMPLETE\n        if (timer)\n          Meteor.clearTimeout(timer);\n\n        if (timed_out) {\n          callback(new Error(\"timeout\"));\n        } else if (! xhr.status) {\n          // no HTTP response\n          callback(new Error(\"network\"));\n        } else {\n\n          var response = {};\n          response.statusCode = xhr.status;\n          response.content = xhr.responseText;\n\n          response.headers = {};\n          var header_str = xhr.getAllResponseHeaders();\n\n          // https://github.com/meteor/meteor/issues/553\n          //\n          // In Firefox there is a weird issue, sometimes\n          // getAllResponseHeaders returns the empty string, but\n          // getResponseHeader returns correct results. Possibly this\n          // issue:\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735\n          //\n          // If this happens we can't get a full list of headers, but\n          // at least get content-type so our JSON decoding happens\n          // correctly. In theory, we could try and rescue more header\n          // values with a list of common headers, but content-type is\n          // the only vital one for now.\n          if (\"\" === header_str && xhr.getResponseHeader(\"content-type\"))\n            header_str =\n            \"content-type: \" + xhr.getResponseHeader(\"content-type\");\n\n          var headers_raw = header_str.split(/\\r?\\n/);\n          _.each(headers_raw, function (h) {\n            var m = /^(.*?):(?:\\s+)(.*)$/.exec(h);\n            if (m && m.length === 3)\n              response.headers[m[1].toLowerCase()] = m[2];\n          });\n\n          populateData(response);\n\n          var error = null;\n          if (response.statusCode >= 400)\n            error = makeErrorByStatus(response.statusCode, response.content);\n\n          callback(error, response);\n        }\n      }\n    };\n\n    // send it on its way\n    xhr.send(content);\n\n  } catch (err) {\n    callback(err);\n  }\n\n};\n","// The HTTP object used to be called Meteor.http.\n// XXX COMPAT WITH 0.6.4\nMeteor.http = HTTP;\n"]}